{
  "hash": "f619b3e6599ab157eea1877f385fce2d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Classification\"\ntype: docs\noutput:\n  blogdown::html_page:\n    toc: true\n---\n\n\n\n\n## Required Reading\n\n- This page.\n- <i class=\"fas fa-book\"></i> [Chapter 4](https://trevorhastie.github.io/ISLR/ISLR%20Seventh%20Printing.pdf) in *Introduction to Statistical Learning with Applications in R*.\n\n### Guiding Questions\n\n- How do we make predictions about binary responses?\n- Why should we be concerned about using simple linear regression?\n- What is the right way to assess the accuracy of such a model?\n\n# Overview {#classification-overview}\n\n**Classification** is a form of **supervised learning** where the response variable is categorical, as opposed to numeric for regression. *Our goal is to find a rule, algorithm, or function which takes as input a feature vector, and outputs a category which is the true category as often as possible.*\n\n![](./img/classification.png)\n\nThat is, the classifier $\\hat{C}(x)$ returns the predicted category $\\hat{y}(X)$.\n\n$$\n\\hat{y}(x) = \\hat{C}(x)\n$$\n\nTo build our first classifier, we will use the `Default` dataset from the `ISLR` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ISLR)\nlibrary(tibble)\nas_tibble(Default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 4\n   default student balance income\n   <fct>   <fct>     <dbl>  <dbl>\n 1 No      No         730. 44362.\n 2 No      Yes        817. 12106.\n 3 No      No        1074. 31767.\n 4 No      No         529. 35704.\n 5 No      No         786. 38463.\n 6 No      Yes        920.  7492.\n 7 No      No         826. 24905.\n 8 No      Yes        809. 17600.\n 9 No      No        1161. 37469.\n10 No      No           0  29275.\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nOur goal is to properly classify individuals as defaulters based on student status, credit card balance, and income. Be aware that the response `default` is a factor, as is the predictor `student`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(Default$default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.factor(Default$student)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nAs we did with regression, we test-train split our data. In this case, using 50% for each.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(44222)\ndefault_idx   = sample(nrow(Default), trunc(nrow(Default)*.5))\ndefault_trn = Default[default_idx, ]\ndefault_tst = Default[-default_idx, ]\n```\n:::\n\n\n\n\n\n## Visualization for Classification\n\nOften, some simple visualizations can suggest simple classification rules. To quickly create some useful visualizations, we use the `featurePlot()` function from the `caret()` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\n```\n:::\n\n\n\n\nA density plot can often suggest a simple split based on a numeric predictor. Essentially this plot graphs a density estimate\n\n$$\n\\hat{f}_{X_i}(x_i \\mid Y = k)\n$$\n\nfor each numeric predictor $x_i$ and each category $k$ of the response $y$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeaturePlot(x = default_trn[, c(\"balance\", \"income\")],\n            y = default_trn$default,\n            plot = \"density\",\n            scales = list(x = list(relation = \"free\"),\n                          y = list(relation = \"free\")),\n            adjust = 1.5,\n            pch = \"|\",\n            layout = c(2, 1),\n            auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n\nSome notes about the arguments to this function:\n\n- `x` is a data frame containing only **numeric predictors**. It would be nonsensical to estimate a density for a categorical predictor.\n- `y` is the response variable. It needs to be a factor variable. If coded as `0` and `1`, you will need to coerce to factor for plotting.\n- `plot` specifies the type of plot, here `density`.\n- `scales` defines the scale of the axes for each plot. By default, the axis of each plot would be the same, which often is not useful, so the arguments here, a different axis for each plot, will almost always be used.\n- `adjust` specifies the amount of smoothing used for the density estimate.\n- `pch` specifies the **p**lot **ch**aracter used for the bottom of the plot.\n- `layout` places the individual plots into rows and columns. For some odd reason, it is given as (col, row).\n- `auto.key` defines the key at the top of the plot. The number of columns should be the number of categories.\n\nIs the `income` variable useful here? How about the `balance` variable? There seems to be a big difference in default status at a `balance` of about 1400. We will use this information shortly.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeaturePlot(x = default_trn[, c(\"balance\", \"income\")],\n            y = default_trn$student,\n            plot = \"density\",\n            scales = list(x = list(relation = \"free\"),\n                          y = list(relation = \"free\")),\n            adjust = 1.5,\n            pch = \"|\",\n            layout = c(2, 1),\n            auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n\n\nAbove, we create a similar plot, except with `student` as the response. It's not that we want to predict `student` -- rather, we want to see if student is correlated with balance or income. We see that students often carry a slightly larger balance, and have far lower income. This will be useful to know when making more complicated classifiers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeaturePlot(x = default_trn[, c(\"student\", \"balance\", \"income\")],\n            y = default_trn$default,\n            plot = \"pairs\",\n            auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-7-1.png){width=576}\n:::\n:::\n\n\n\n\nWe can use `plot = \"pairs\"` to consider multiple variables at the same time. This plot reinforces using `balance` to create a classifier, and again shows that `income` seems not that useful.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ellipse)\nfeaturePlot(x = default_trn[, c(\"balance\", \"income\")],\n            y = default_trn$default,\n            plot = \"ellipse\",\n            auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-8-1.png){width=576}\n:::\n:::\n\n\n\n\nSimilar to `pairs` is a plot of type `ellipse`, which requires the `ellipse` package. Here we only use numeric predictors, as essentially we are assuming multivariate normality. The ellipses mark points of equal density. This will be useful later when discussing LDA and QDA.\n\n\n## A Simple Classifier\n\nA very simple classifier is a rule based on a boundary $b$ for a particular input variable $x$.\n\n$$\n\\hat{C}(x) =\n\\begin{cases}\n      1 & x > b \\\\\n      0 & x \\leq b\n\\end{cases}\n$$\n\nBased on the first plot, we believe we can use `balance` to create a reasonable classifier. In particular,\n\n$$\n\\hat{C}(\\texttt{balance}) =\n\\begin{cases}\n      \\text{Yes} & \\texttt{balance} > 1400 \\\\\n      \\text{No} & \\texttt{balance} \\leq 1400\n   \\end{cases}\n$$\n\nSo we predict an individual is a defaulter if their `balance` is above 1400, and not a defaulter if the balance is 1400 or less.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_class = function(x, boundary, above = 1, below = 0) {\n  ifelse(x > boundary, above, below)\n}\n```\n:::\n\n\n\n\nWe write a simple `R` function that compares a variable to a boundary, then use it to make predictions on the train and test sets with our chosen variable and boundary.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndefault_trn_pred = simple_class(x = default_trn$balance,\n                                boundary = 1400, above = \"Yes\", below = \"No\")\ndefault_tst_pred = simple_class(x = default_tst$balance,\n                                boundary = 1400, above = \"Yes\", below = \"No\")\nhead(default_tst_pred, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"No\" \"No\" \"No\" \"No\" \"No\" \"No\" \"No\" \"No\" \"No\" \"No\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Metrics for Classification\n\nIn the classification setting, there are a large number of metrics to assess how well a classifier is performing.\n\nOne of the most obvious things to do is arrange predictions and true values in a cross table.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(trn_tab = table(predicted = default_trn_pred, actual = default_trn$default))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         actual\npredicted   No  Yes\n      No  4337   23\n      Yes  496  144\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(tst_tab = table(predicted = default_tst_pred, actual = default_tst$default))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         actual\npredicted   No  Yes\n      No  4343   29\n      Yes  491  137\n```\n\n\n:::\n:::\n\n\n\n\nOften we give specific names to individual cells of these tables, and in the predictive setting, we would call this table a [**confusion matrix**](https://en.wikipedia.org/wiki/Confusion_matrix). Be aware, that the placement of Actual and Predicted values affects the names of the cells, and often the matrix may be presented transposed.\n\nIn statistics, we label the errors Type I and Type II, but these are hard to remember. False Positive and False Negative are more descriptive, so we choose to use these.\n\n<!-- ![](images/confusion.png) -->\n\nThe `confusionMatrix()` function from the `caret` package can be used to obtain a wealth of additional information, which we see output below for the test data. Note that we specify which category is considered \"positive.\"\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrn_con_mat  = confusionMatrix(trn_tab, positive = \"Yes\")\ntst_con_mat = confusionMatrix(tst_tab, positive = \"Yes\")\ntst_con_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nConfusion Matrix and Statistics\n\n         actual\npredicted   No  Yes\n      No  4343   29\n      Yes  491  137\n                                          \n               Accuracy : 0.896           \n                 95% CI : (0.8872, 0.9043)\n    No Information Rate : 0.9668          \n    P-Value [Acc > NIR] : 1               \n                                          \n                  Kappa : 0.3088          \n                                          \n Mcnemar's Test P-Value : <2e-16          \n                                          \n            Sensitivity : 0.8253          \n            Specificity : 0.8984          \n         Pos Pred Value : 0.2182          \n         Neg Pred Value : 0.9934          \n             Prevalence : 0.0332          \n         Detection Rate : 0.0274          \n   Detection Prevalence : 0.1256          \n      Balanced Accuracy : 0.8619          \n                                          \n       'Positive' Class : Yes             \n                                          \n```\n\n\n:::\n:::\n\n\n\n\nThe most common, and most important metric is the **classification error rate**.\n\n$$\n\\text{err}(\\hat{C}, \\text{Data}) = \\frac{1}{n}\\sum_{i = 1}^{n}I(y_i \\neq \\hat{C}(x_i))\n$$\n\nHere, $I$ is an indicator function, so we are essentially calculating the proportion of predicted classes that match the true class.\n\n$$\nI(y_i \\neq \\hat{C}(x)) =\n\\begin{cases}\n  1 & y_i \\neq \\hat{C}(x) \\\\\n  0 & y_i = \\hat{C}(x) \\\\\n\\end{cases}\n$$\n\nIt is also common to discuss the **accuracy**, which is simply one minus the error.\n\nLike regression, we often split the data, and then consider Train (Classification) Error and Test (Classification) Error will be used as a measure of how well a classifier will work on unseen future data.\n\n$$\n\\text{err}_{\\texttt{trn}}(\\hat{C}, \\text{Train Data}) = \\frac{1}{n_{\\texttt{trn}}}\\sum_{i \\in \\texttt{trn}}^{}I(y_i \\neq \\hat{C}(x_i))\n$$\n\n$$\n\\text{err}_{\\texttt{tst}}(\\hat{C}, \\text{Test Data}) = \\frac{1}{n_{\\texttt{tst}}}\\sum_{i \\in \\texttt{tst}}^{}I(y_i \\neq \\hat{C}(x_i))\n$$\n\nAccuracy values can be found by calling `confusionMatrix()`, or, if stored, can be accessed directly. Here, we use them to obtain **error rates** (1-Accuracy).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n 1 - trn_con_mat$overall[\"Accuracy\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAccuracy \n  0.1038 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Note, R doesn't know to rename the result \"err\", so it keeps the name \"Accuracy\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - tst_con_mat$overall[\"Accuracy\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAccuracy \n   0.104 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Note, R doesn't know to rename the result \"err\", so it keeps the name \"Accuracy\"\n```\n:::\n\n\n\n\nWe can go back to the `tst_con_mat` table before and hand-calculate accuracy\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - ((4319 + 130) / 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1102\n```\n\n\n:::\n:::\n\n\n\n\n\nFirst some notation:\n\n- $P$ is the total number of actual positives\n- $TP$ is the total number of actual positives predicted to be positive\n- $N$ is the total number of actual negatives\n- $TN$ is the total number of actual negatives predicted to be negative\n- $FP$ and $FN$ are the total number of false positives and false negatives\n\nWhich means...\n\n- $P = TP + FN$ \n- $N = TN + FP$\n\nSometimes guarding against making certain errors, FP or FN, are more important than simply finding the best accuracy. Thus, sometimes we will consider **sensitivity** and **specificity**.\n\n$$\n\\text{Sensitivity} = \\text{True Positive Rate} = \\frac{\\text{TP}}{\\text{P}} = \\frac{\\text{TP}}{\\text{TP + FN}}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntst_con_mat$byClass[\"Sensitivity\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSensitivity \n  0.8253012 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 130/(130+28)\n```\n:::\n\n\n\n\nThis is the *share of actually-\"yes\" observations that were predicted by the model to be \"yes\"*\n\n$$\n\\text{Specificity} = \\text{True Negative Rate} = \\frac{\\text{TN}}{\\text{N}} = \\frac{\\text{TN}}{\\text{TN + FP}}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntst_con_mat$byClass[\"Specificity\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpecificity \n  0.8984278 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 4319/(4319/523)\n```\n:::\n\n\n\n\nSpecificity is the *share of actually-\"no\" observations that were predicted by the model to be \"no\"*\n\nLike accuracy, these can easily be found using `confusionMatrix()`.\n\nWhen considering how well a classifier is performing, often, it is understandable to assume that any accuracy in a binary classification problem above 0.50 is a reasonable classifier. This however is not the case. We need to consider the **balance** of the classes. To do so, we look at the **prevalence** of positive cases.\n\n$$\n\\text{Prev} = \\frac{\\text{P}}{\\text{Total Obs}}= \\frac{\\text{TP + FN}}{\\text{Total Obs}}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrn_con_mat$byClass[\"Prevalence\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPrevalence \n    0.0334 \n```\n\n\n:::\n\n```{.r .cell-code}\ntst_con_mat$byClass[\"Prevalence\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPrevalence \n    0.0332 \n```\n\n\n:::\n\n```{.r .cell-code}\n# (28+130)/5000\n```\n:::\n\n\n\n\nHere, we see an extremely low prevalence, which suggests an even simpler classifier than our current based on `balance`.\n\n$$\n\\hat{C}(\\texttt{balance}) =\n\\begin{cases}\n      \\text{No} & \\texttt{balance} > 1400 \\\\\n      \\text{No} & \\texttt{balance} \\leq 1400\n   \\end{cases}\n$$\n\nThis classifier simply classifies all observations as negative cases.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_all_no = simple_class(default_tst$balance,\n                           boundary = 1400, above = \"No\", below = \"No\")\ntable(predicted = pred_all_no, actual = default_tst$default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         actual\npredicted   No  Yes\n       No 4834  166\n```\n\n\n:::\n:::\n\n\n\n\nThe `confusionMatrix()` function won't even accept this table as input, because it isn't a full matrix, only one row, so we calculate error rates directly. To do so, we write a function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_class_err = function(actual, predicted) {\n  mean(actual != predicted)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_class_err(actual = default_tst$default,\n               predicted = pred_all_no)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0332\n```\n\n\n:::\n:::\n\n\n\n\nHere we see that the error rate is exactly the prevelance of the minority class.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(default_tst$default) / length(default_tst$default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    No    Yes \n0.9668 0.0332 \n```\n\n\n:::\n:::\n\n\n\n\nThis classifier does better than the previous. But the point is, in reality, to create a good classifier, we should obtain a test error better than 0.033, which is obtained by simply manipulating the prevalences. Next section, we'll introduce much better classifiers which should have no problem accomplishing this task. Point is, think carefully about what you're putting your classifier up against. Last March when we were very worried about COVID test accuracy, and when *prevalance* was, say, 1%, it was pointed out that we could make a 99% accurate COVID test by simply returning \"No COVID\" for every test! We'd be the new Theranos!\n\n\n# Logistic Regression\n\n\nIn this section, we continue our discussion of classification. We introduce our first model for classification, logistic regression. To begin, we return to the `Default` dataset from above.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ISLR)\nlibrary(tibble)\nas_tibble(Default)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 4\n   default student balance income\n   <fct>   <fct>     <dbl>  <dbl>\n 1 No      No         730. 44362.\n 2 No      Yes        817. 12106.\n 3 No      No        1074. 31767.\n 4 No      No         529. 35704.\n 5 No      No         786. 38463.\n 6 No      Yes        920.  7492.\n 7 No      No         826. 24905.\n 8 No      Yes        809. 17600.\n 9 No      No        1161. 37469.\n10 No      No           0  29275.\n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe also repeat the test-train split from above (you need not repeat this step if you have this saved).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\ndefault_idx = sample(nrow(Default), 5000)\ndefault_trn = Default[default_idx, ]\ndefault_tst = Default[-default_idx, ]\n```\n:::\n\n\n\n\n## Linear Regression and Binary Responses\n\nBefore moving on to logistic regression, why not plain, old, linear regression?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndefault_trn_lm = default_trn\ndefault_tst_lm = default_tst\n```\n:::\n\n\n\n\nSince linear regression expects a numeric response variable, we coerce the response to be numeric. (Notice that we also shift the results, as we require `0` and `1`, not `1` and `2`.) Notice we have also copied the dataset so that we can return the original data with factors later.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndefault_trn_lm$default = as.numeric(default_trn_lm$default) - 1\ndefault_tst_lm$default = as.numeric(default_tst_lm$default) - 1\n```\n:::\n\n\n\n\nWhy would we think this should work? Recall that,\n\n$$\n\\hat{\\mathbb{E}}[Y \\mid X = x] = X\\hat{\\beta}.\n$$\n\nSince $Y$ is limited to values of $0$ and $1$, we have\n\n$$\n\\mathbb{E}[Y \\mid X = x] = P(Y = 1 \\mid X = x).\n$$\n\nIt would then seem reasonable that $\\mathbf{X}\\hat{\\beta}$ is a reasonable estimate of $P(Y = 1 \\mid X = x)$. We test this on the `Default` data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_lm = lm(default ~ balance, data = default_trn_lm)\n```\n:::\n\n\n\n\nEverything seems to be working, until we plot the results.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(default ~ balance, data = default_trn_lm,\n     col = \"darkorange\", pch = \"|\", ylim = c(-0.2, 1),\n     main = \"Using Linear Regression for Classification\")\nabline(h = 0, lty = 3)\nabline(h = 1, lty = 3)\nabline(h = 0.5, lty = 2)\nabline(model_lm, lwd = 3, col = \"dodgerblue\")\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\nTwo issues arise. First, all of the predicted probabilities are below 0.5. That means, we would classify every observation as a `\"No\"`. This is certainly possible, but not what we would expect.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(predict(model_lm) < 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThe next, and bigger issue, is predicted probabilities less than 0.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(predict(model_lm) < 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n## Bayes Classifier\n\nWhy are we using a predicted probability of 0.5 as the cutoff for classification? Recall, the Bayes Classifier, which minimizes the classification error:\n\n$$\nC^B(x) = \\underset{g}{\\mathrm{argmax}} \\ P(Y = g \\mid  X = x)\n$$\n\nSo, in the binary classification problem, we will use predicted probabilities\n\n$$\n\\hat{p}(x) = \\hat{P}(Y = 1 \\mid { X = x})\n$$\n\nand\n\n$$\n\\hat{P}(Y = 0 \\mid { X = x})\n$$\n\nand then classify to the larger of the two. We actually only need to consider a single probability, usually $\\hat{P}(Y = 1 \\mid { X = x})$. Since we use it so often, we give it the shorthand notation, $\\hat{p}(x)$. Then the classifier is written,\n\n$$\n\\hat{C}(x) =\n\\begin{cases}\n      1 & \\hat{p}(x) > 0.5 \\\\\n      0 & \\hat{p}(x) \\leq 0.5\n\\end{cases}\n$$\n\nThis classifier is essentially estimating the Bayes Classifier - it takes the value of $x$, figures out which is larger, the $\\hat{P}(Y=1|X=x)$ or $\\hat{P}(Y=0 | X=x)$, and returns the classification $\\hat{C}(x)$ as whichever probability is larger. Since there are only two values for $Y\\in\\{0,1\\}$, the larger is always the one greater than $.50$. Thus, since this is a Bayes Classifier, it minimizes classification errors.\n\n\n## Logistic Regression with `glm()`\n\nTo better estimate the probability\n\n$$\np(x) = P(Y = 1 \\mid {X = x})\n$$\nwe turn to logistic regression. The model is written\n\n$$\n\\log\\left(\\frac{p(x)}{1 - p(x)}\\right) = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\cdots  + \\beta_p x_p.\n$$\n\nRearranging, we see the probabilities can be written as\n\n$$\np(x) = \\frac{1}{1 + e^{-(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\cdots  + \\beta_p x_p)}} = \\sigma(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\cdots  + \\beta_p x_p)\n$$\n\nNotice, we use the sigmoid function as shorthand notation, which appears often in deep learning literature. It takes any real input, and outputs a number between 0 and 1. How useful! (This is actualy a particular sigmoid function called the logistic function, but since it is by far the most popular sigmoid function, often sigmoid function is used to refer to the logistic function)\n\n$$\n\\sigma(x) = \\frac{e^x}{1 + e^x} = \\frac{1}{1 + e^{-x}}\n$$\n\nThe model is fit by numerically maximizing the likelihood, which we will let `R` take care of. Essentially, `R` is going to try a whole bunch of guesses for $\\mathbf{\\beta}$ and choose the one that best explains the data we have.\n\nWe start with a single predictor example, again using `balance` as our single predictor. Note that `default_trn` has a factor variable for `default` (No/Yes). Since `R` represents factor variables as numbers (here, 1 and 2), `glm` figures out that you mean `No` and `Yes` for `0` and `1`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_glm = glm(default ~ balance, data = default_trn, family = \"binomial\")\n```\n:::\n\n\n\n\nFitting this model looks very similar to fitting a simple linear regression. Instead of `lm()` we use `glm()`. The only other difference is the use of `family = \"binomial\"` which indicates that we have a two-class categorical response. Using `glm()` with `family = \"gaussian\"` would perform the usual linear regression.\n\nFirst, we can obtain the fitted coefficients the same way we did with linear regression.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(model_glm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)       balance \n-10.493158288   0.005424994 \n```\n\n\n:::\n:::\n\n\n\n\nThe next thing we should understand is how the `predict()` function works with `glm()`. So, let's look at some predictions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(predict(model_glm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     2369      5273      9290      1252      8826       356 \n-5.376670 -4.875653 -5.018746 -4.007664 -6.538414 -6.601582 \n```\n\n\n:::\n:::\n\n\n\n\nBy default, `predict.glm()` uses `type = \"link\"`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(predict(model_glm, type = \"link\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     2369      5273      9290      1252      8826       356 \n-5.376670 -4.875653 -5.018746 -4.007664 -6.538414 -6.601582 \n```\n\n\n:::\n:::\n\n\n\n\nThat is, `R` is returning\n\n$$\n\\hat{\\beta}_0 + \\hat{\\beta}_1 x_1 + \\hat{\\beta}_2 x_2 + \\cdots  + \\hat{\\beta}_p x_p\n$$\nfor each observation.\n\nImportantly, these are **not** predicted probabilities. To obtain the predicted probabilities\n\n$$\n\\hat{p}(x) = \\hat{P}(Y = 1 \\mid X = x)\n$$\n\nwe need to use `type = \"response\"`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(predict(model_glm, type = \"response\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       2369        5273        9290        1252        8826         356 \n0.004601914 0.007572331 0.006569370 0.017851333 0.001444691 0.001356375 \n```\n\n\n:::\n:::\n\n\n\n\nNote that these are probabilities, **not** classifications. To obtain classifications, we will need to compare to the correct cutoff value with an `ifelse()` statement.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_glm_pred = ifelse(predict(model_glm, type = \"link\") > 0, \"Yes\", \"No\")\n# model_glm_pred = ifelse(predict(model_glm, type = \"response\") > 0.5, \"Yes\", \"No\")\n```\n:::\n\n\n\n\nThe line that is run is performing\n\n$$\n\\hat{C}(x) =\n\\begin{cases}\n      1 & \\hat{f}(x) > 0 \\\\\n      0 & \\hat{f}(x) \\leq 0\n\\end{cases}\n$$\n\nwhere\n\n$$\n\\hat{f}(x) =\\hat{\\beta}_0 + \\hat{\\beta}_1 x_1 + \\hat{\\beta}_2 x_2 + \\cdots  + \\hat{\\beta}_p x_p.\n$$\n\nThe commented line, which would give the same results, is performing\n\n$$\n\\hat{C}(x) =\n\\begin{cases}\n      1 & \\hat{p}(x) > 0.5 \\\\\n      0 & \\hat{p}(x) \\leq 0.5\n\\end{cases}\n$$\n\nwhere\n\n$$\n\\hat{p}(x) = \\hat{P}(Y = 1 \\mid X = x).\n$$\n\nOnce we have classifications, we can calculate metrics such as the training classification error rate.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_class_err = function(actual, predicted) {\n  mean(actual != predicted)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_class_err(actual = default_trn$default, predicted = model_glm_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0284\n```\n\n\n:::\n:::\n\n\n\n\nAs we saw previously, the `table()` and `confusionMatrix()` functions can be used to quickly obtain many more metrics.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_tab = table(predicted = model_glm_pred, actual = default_trn$default)\nlibrary(caret)\ntrain_con_mat = confusionMatrix(train_tab, positive = \"Yes\")\nc(train_con_mat$overall[\"Accuracy\"],\n  train_con_mat$byClass[\"Sensitivity\"],\n  train_con_mat$byClass[\"Specificity\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Accuracy Sensitivity Specificity \n  0.9716000   0.2941176   0.9954451 \n```\n\n\n:::\n:::\n\n\n\n\nWe could also write a custom function for the error for use with trained logistic regression models.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_logistic_error = function(mod, data, res = \"y\", pos = 1, neg = 0, cut = 0.5) {\n  probs = predict(mod, newdata = data, type = \"response\")\n  preds = ifelse(probs > cut, pos, neg)\n  calc_class_err(actual = data[, res], predicted = preds)\n}\n```\n:::\n\n\n\n\nThis function will be useful later when calculating train and test errors for several models at the same time.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_logistic_error(model_glm, data = default_trn,\n                   res = \"default\", pos = \"Yes\", neg = \"No\", cut = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0284\n```\n\n\n:::\n:::\n\n\n\n\nTo see how much better logistic regression is for this task, we create the same plot we used for linear regression.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(default ~ balance, data = default_trn_lm,\n     col = \"darkorange\", pch = \"|\", ylim = c(-0.2, 1),\n     main = \"Using Logistic Regression for Classification\")\nabline(h = 0, lty = 3)\nabline(h = 1, lty = 3)\nabline(h = 0.5, lty = 2)\ncurve(predict(model_glm, data.frame(balance = x), type = \"response\"),\n      add = TRUE, lwd = 3, col = \"dodgerblue\")\nabline(v = -coef(model_glm)[1] / coef(model_glm)[2], lwd = 2)\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n\n\nThis plot contains a wealth of information.\n\n- The orange `|` characters are the data, $(x_i, y_i)$.\n- The blue \"curve\" is the predicted probabilities given by the fitted logistic regression. That is,\n$$\n\\hat{p}(x) = \\hat{P}(Y = 1 \\mid { X = x})\n$$\n- The solid vertical black line represents the **[decision boundary](https://en.wikipedia.org/wiki/Decision_boundary)**, the `balance` that obtains a predicted probability of 0.5. In this case `balance` = 1934.2247145.\n\nThe decision boundary is found by solving for points that satisfy\n\n$$\n\\hat{p}(x) = \\hat{P}(Y = 1 \\mid { X = x}) = 0.5\n$$\n\nThis is equivalent to point that satisfy\n\n$$\n\\hat{\\beta}_0 + \\hat{\\beta}_1 x_1 = 0.\n$$\nThus, for logistic regression with a single predictor, the decision boundary is given by the *point*\n\n$$\nx_1 = \\frac{-\\hat{\\beta}_0}{\\hat{\\beta}_1}.\n$$\n\nThe following is not run, but an alternative way to add the logistic curve to the plot.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid = seq(0, max(default_trn$balance), by = 0.01)\n\nsigmoid = function(x) {\n  1 / (1 + exp(-x))\n}\n\nlines(grid, sigmoid(coef(model_glm)[1] + coef(model_glm)[2] * grid), lwd = 3)\n```\n:::\n\n\n\n\n\nUsing the usual formula syntax, it is easy to add or remove complexity from logistic regressions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_1 = glm(default ~ 1, data = default_trn, family = \"binomial\")\nmodel_2 = glm(default ~ ., data = default_trn, family = \"binomial\")\nmodel_3 = glm(default ~ . ^ 2 + I(balance ^ 2),\n              data = default_trn, family = \"binomial\")\n```\n:::\n\n\n\n\nNote that, using polynomial transformations of predictors will allow a linear model to have non-linear decision boundaries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_list = list(model_1, model_2, model_3)\ntrain_errors = sapply(model_list, get_logistic_error, data = default_trn,\n                      res = \"default\", pos = \"Yes\", neg = \"No\", cut = 0.5)\ntest_errors  = sapply(model_list, get_logistic_error, data = default_tst,\n                      res = \"default\", pos = \"Yes\", neg = \"No\", cut = 0.5)\n\nknitr::kable(cbind(train_errors, test_errors))\n```\n\n::: {.cell-output-display}\n\n\n| train_errors| test_errors|\n|------------:|-----------:|\n|       0.0340|      0.0326|\n|       0.0274|      0.0258|\n|       0.0274|      0.0264|\n\n\n:::\n:::\n\n\n\n\nHere we see the misclassification error rates for each model. The train (weakly) decreases, and the test decreases, until it starts to increases. Everything we learned about the bias-variance tradeoff for regression also applies here.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff(train_errors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.0066  0.0000\n```\n\n\n:::\n\n```{.r .cell-code}\ndiff(test_errors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.0068  0.0006\n```\n\n\n:::\n:::\n\n\n\n\nWe call `model_2` the **additive** logistic model, which we will use quite often.\n\n\n## ROC Curves\n\nLet's return to our simple model with only balance as a predictor.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_glm = glm(default ~ balance, data = default_trn, family = \"binomial\")\n```\n:::\n\n\n\n\nWe write a function which allows use to make predictions based on different probability cutoffs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_logistic_pred = function(mod, data, res = \"y\", pos = 1, neg = 0, cut = 0.5) {\n  probs = predict(mod, newdata = data, type = \"response\")\n  ifelse(probs > cut, pos, neg)\n}\n```\n:::\n\n\n\n\n$$\n\\hat{C}(x) =\n\\begin{cases}\n      1 & \\hat{p}(x) > c \\\\\n      0 & \\hat{p}(x) \\leq c\n\\end{cases}\n$$\n\nLet's use this to obtain predictions using a low, medium, and high cutoff. (0.1, 0.5, and 0.9)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_pred_10 = get_logistic_pred(model_glm, data = default_tst, res = \"default\",\n                                 pos = \"Yes\", neg = \"No\", cut = 0.1)\ntest_pred_50 = get_logistic_pred(model_glm, data = default_tst, res = \"default\",\n                                 pos = \"Yes\", neg = \"No\", cut = 0.5)\ntest_pred_90 = get_logistic_pred(model_glm, data = default_tst, res = \"default\",\n                                 pos = \"Yes\", neg = \"No\", cut = 0.9)\n```\n:::\n\n\n\n\nNow we evaluate accuracy, sensitivity, and specificity for these classifiers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_tab_10 = table(predicted = test_pred_10, actual = default_tst$default)\ntest_tab_50 = table(predicted = test_pred_50, actual = default_tst$default)\ntest_tab_90 = table(predicted = test_pred_90, actual = default_tst$default)\n\ntest_con_mat_10 = confusionMatrix(test_tab_10, positive = \"Yes\")\ntest_con_mat_50 = confusionMatrix(test_tab_50, positive = \"Yes\")\ntest_con_mat_90 = confusionMatrix(test_tab_90, positive = \"Yes\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmetrics = rbind(\n\n  c(test_con_mat_10$overall[\"Accuracy\"],\n    test_con_mat_10$byClass[\"Sensitivity\"],\n    test_con_mat_10$byClass[\"Specificity\"]),\n\n  c(test_con_mat_50$overall[\"Accuracy\"],\n    test_con_mat_50$byClass[\"Sensitivity\"],\n    test_con_mat_50$byClass[\"Specificity\"]),\n\n  c(test_con_mat_90$overall[\"Accuracy\"],\n    test_con_mat_90$byClass[\"Sensitivity\"],\n    test_con_mat_90$byClass[\"Specificity\"])\n\n)\n\nrownames(metrics) = c(\"c = 0.10\", \"c = 0.50\", \"c = 0.90\")\nmetrics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Accuracy Sensitivity Specificity\nc = 0.10   0.9328  0.71779141   0.9400455\nc = 0.50   0.9730  0.31288344   0.9952450\nc = 0.90   0.9688  0.04294479   1.0000000\n```\n\n\n:::\n:::\n\n\n\n\nWe see then sensitivity decreases as the cutoff is increased. Conversely, specificity increases as the cutoff increases. This is useful if we are more interested in a particular error, instead of giving them equal weight.\n\nNote that usually the best accuracy will be seen near $c = 0.50$. This is not always true, and in your lab, you may need to change your cutoff.\n\nInstead of manually checking cutoffs, we can create an ROC curve (receiver operating characteristic curve) which will sweep through all possible cutoffs, and plot the sensitivity and specificity. \n\n- **Where on this curve would you think is the \"best\" place to be? Why?**\n\n- **Where on this curve would you think is the \"worst\" place to be? Why?**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\ntest_prob = predict(model_glm, newdata = default_tst, type = \"response\")\ntest_roc = roc(default_tst$default ~ test_prob, plot = TRUE, print.auc = TRUE)\n```\n\n::: {.cell-output-display}\n![](12a_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n\n```{.r .cell-code}\nas.numeric(test_roc$auc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9492866\n```\n\n\n:::\n:::\n\n\n\n\nThe AUC is the \"area under the curve\". One interpretation of the AUC is that it is \"the probability that the model ranks a randomly selected positive more highly than a randomly selected negative.\" A good model will have a high AUC. A high AUC has a high sensitivity and a high specificity over all of the cutoff values.\n\n\n## Multinomial Logistic Regression\n\nWhat if the response contains more than two categories? For that we need multinomial logistic regression.\n\n$$\nP(Y = k \\mid { X = x}) = \\frac{e^{\\beta_{0k} + \\beta_{1k} x_1 + \\cdots +  + \\beta_{pk} x_p}}{\\sum_{g = 1}^{G} e^{\\beta_{0g} + \\beta_{1g} x_1 + \\cdots + \\beta_{pg} x_p}}\n$$\n\nWe will omit the details, as ISL has as well. If you are interested, the [Wikipedia page](https://en.wikipedia.org/wiki/Multinomial_logistic_regression) provides a rather thorough coverage. Also note that the above is an example of the [softmax function](https://en.wikipedia.org/wiki/Softmax_function).\n\nAs an example of a dataset with a three category response, we use the `iris` dataset, which is so famous, it has its own [Wikipedia entry](https://en.wikipedia.org/wiki/Iris_flower_data_set). It is also a default dataset in `R`, so no need to load it.\n\nBefore proceeding, we test-train split this data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(430)\niris_obs = nrow(iris)\niris_idx = sample(iris_obs, size = trunc(0.50 * iris_obs))\niris_trn = iris[iris_idx, ]\niris_test = iris[-iris_idx, ]\n```\n:::\n\n\n\n\nTo perform multinomial logistic regression, we use the `multinom` function from the `nnet` package. Training using `multinom()` is done using similar syntax to `lm()` and `glm()`. We add the `trace = FALSE` argument to suppress information about updates to the optimization routine as the model is trained.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nnet)\nmodel_multi = multinom(Species ~ ., data = iris_trn, trace = FALSE)\nsummary(model_multi)$coefficients\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           (Intercept) Sepal.Length Sepal.Width Petal.Length Petal.Width\nversicolor    16.77474    -7.855576   -13.98668     25.13860    4.270375\nvirginica    -33.94895   -37.519645   -94.22846     97.82691   73.487162\n```\n\n\n:::\n:::\n\n\n\n\nNotice we are only given coefficients for two of the three class, much like only needing coefficients for one class in logistic regression.\n\nA difference between `glm()` and `multinom()` is how the `predict()` function operates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(predict(model_multi, newdata = iris_trn))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] setosa     versicolor versicolor setosa     virginica  versicolor\nLevels: setosa versicolor virginica\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(predict(model_multi, newdata = iris_trn, type = \"prob\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          setosa   versicolor     virginica\n1   1.000000e+00 1.910554e-16 6.118616e-176\n92  8.542846e-22 1.000000e+00  1.372168e-18\n77  8.343856e-23 1.000000e+00  2.527471e-14\n38  1.000000e+00 1.481126e-16 5.777917e-180\n108 1.835279e-73 1.403654e-36  1.000000e+00\n83  1.256090e-16 1.000000e+00  2.223689e-32\n```\n\n\n:::\n:::\n\n\n\n\nNotice that by default, classifications are returned. When obtaining probabilities, we are given the predicted probability for **each** class.\n\nInterestingly, you've just fit a neural network, and you didn't even know it! (Hence the `nnet` package.) Later we will discuss the connections between logistic regression, multinomial logistic regression, and simple neural networks. \n\n\n",
    "supporting": [
      "12a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}